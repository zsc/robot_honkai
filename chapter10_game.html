<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬åç«  - å‡¯ç‘Ÿç³çš„è¯•ç‚¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: "å¾®è½¯é›…é»‘", Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* æ¸¸æˆç”»å¸ƒ - ä¼˜åŒ–èƒŒæ™¯ */
        #gameCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, 
                #0a0e27 0%, 
                #151b3d 30%, 
                #1e2654 60%, 
                #2a3670 85%, 
                #384490 100%);
        }

        /* è™šæ‹Ÿè®­ç»ƒå®¤ç½‘æ ¼æ•ˆæœ - æ›´ç»†è…» */
        .grid-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(0deg, rgba(0, 206, 209, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 206, 209, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            animation: gridScroll 20s linear infinite;
        }

        @keyframes gridScroll {
            0% { transform: translate(0, 0); }
            100% { transform: translate(40px, 40px); }
        }
        
        /* åœ°é¢æ•ˆæœ */
        .ground-line {
            position: absolute;
            width: 100%;
            height: 2px;
            bottom: 100px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(0, 206, 209, 0.5), 
                rgba(0, 206, 209, 0.8),
                rgba(0, 206, 209, 0.5),
                transparent);
            box-shadow: 0 0 20px rgba(0, 206, 209, 0.5);
        }

        /* æ´¾è’™åŠ©æ‰‹ - è°ƒæ•´ä½ç½®é¿å…é®æŒ¡ */
        .paimon {
            position: fixed;
            top: 120px;
            right: 30px;
            width: 60px;
            height: 60px;
            z-index: 100;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255, 182, 193, 0.5));
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        /* æ´¾è’™å¯¹è¯æ¡† - ä¼˜åŒ–ä½ç½®å’Œæ ·å¼ */
        .paimon-dialog {
            position: fixed;
            top: 120px;
            right: 100px;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 20, 60, 0.95));
            border: 2px solid rgba(255, 182, 193, 0.8);
            border-radius: 15px;
            padding: 15px 20px;
            max-width: 280px;
            color: #fff;
            font-size: 14px;
            line-height: 1.6;
            z-index: 101;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
        }

        .paimon-dialog.active {
            opacity: 1;
            transform: scale(1);
        }

        .paimon-dialog::after {
            content: '';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid rgba(255, 182, 193, 0.8);
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }

        /* æ•™å­¦æç¤º - ç§»åˆ°é¡¶éƒ¨é¿å…é®æŒ¡ */
        .tutorial-hint {
            position: fixed;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 60, 90, 0.95));
            border: 2px solid rgba(0, 206, 209, 0.8);
            border-radius: 10px;
            padding: 15px 35px;
            color: #00CED1;
            font-size: 16px;
            text-align: center;
            z-index: 90;
            animation: pulse 2s ease-in-out infinite;
            box-shadow: 0 5px 25px rgba(0, 206, 209, 0.3);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 206, 209, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 206, 209, 0.8); }
        }

        .key-hint {
            display: inline-block;
            background: rgba(155, 89, 182, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-weight: bold;
            color: #fff;
        }

        /* ä»»åŠ¡ç›®æ ‡ - ä¼˜åŒ–æ ·å¼ */
        .mission-objective {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(40, 30, 0, 0.9), rgba(60, 45, 0, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 10px;
            padding: 12px 35px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            z-index: 80;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* è¿›åº¦æ¡ - ä¼˜åŒ–æ ·å¼ */
        .progress-bar {
            position: fixed;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            width: 350px;
            height: 24px;
            background: linear-gradient(90deg, rgba(0, 20, 40, 0.8), rgba(0, 40, 60, 0.8));
            border: 2px solid rgba(0, 206, 209, 0.6);
            border-radius: 12px;
            overflow: hidden;
            z-index: 80;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5), 0 2px 15px rgba(0, 206, 209, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00CED1, #00FF7F);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* ç©å®¶æœºç”² - ä¼˜åŒ–å¤§å°å’Œä½ç½® */
        .player-mecha {
            position: absolute;
            width: 100px;
            height: 120px;
            bottom: 102px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease;
            filter: drop-shadow(0 0 15px rgba(255, 105, 180, 0.5));
            z-index: 50;
        }

        /* è®­ç»ƒå‡äºº */
        .training-dummy {
            position: absolute;
            width: 60px;
            height: 80px;
            bottom: 100px;
        }

        /* å…¨æ¯é¶æ ‡ */
        .hologram-target {
            position: absolute;
            width: 50px;
            height: 50px;
            animation: hologramPulse 2s ease-in-out infinite;
        }

        @keyframes hologramPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* å­å¼¹ */
        .bullet {
            position: absolute;
            width: 20px;
            height: 5px;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            border-radius: 50%;
            box-shadow: 0 0 10px #FFD700;
        }

        /* å…ƒç´ æ•ˆæœ */
        .element-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
            animation: elementExpand 0.5s ease-out forwards;
        }

        @keyframes elementExpand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* ä¼¤å®³æ•°å­— */
        .damage-number {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }

        @keyframes damageFloat {
            0% { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(-50px) scale(0.5); 
                opacity: 0; 
            }
        }

        .damage-normal { color: #FFD700; }
        .damage-critical { color: #FF6347; font-size: 32px; }
        .damage-elemental { color: #9B59B6; }

        /* æ§åˆ¶æŒ‰é’®ï¼ˆç§»åŠ¨ç«¯ï¼‰ */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            z-index: 100;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 206, 209, 0.5);
            border-radius: 50%;
            color: #00CED1;
            font-size: 20px;
            margin: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .control-btn:active {
            background: rgba(0, 206, 209, 0.3);
        }

        /* æˆå°±æç¤º - ä¼˜åŒ–æ ·å¼ */
        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 200;
            animation: achievementPop 0.5s ease-out forwards;
            box-shadow: 0 10px 50px rgba(255, 215, 0, 0.5);
        }

        @keyframes achievementPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }

        .achievement h2 {
            color: #8B4513;
            margin-bottom: 10px;
        }

        .achievement p {
            color: #654321;
        }

        /* å‡¯ç‘Ÿç³NPC - è°ƒæ•´ä½ç½® */
        .katherine {
            position: absolute;
            width: 80px;
            height: 120px;
            bottom: 102px;
            left: 50px;
            z-index: 45;
            filter: drop-shadow(0 0 10px rgba(155, 89, 182, 0.5));
        }

        /* å…ƒç´ æ•™å­¦åŒºåŸŸ */
        .element-tutorial-zone {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(155, 89, 182, 0.5);
            border-radius: 10px;
            background: rgba(155, 89, 182, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #9B59B6;
        }

        /* HUDè¦†ç›–å±‚ */
        .hud-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 70;
        }

        /* æŠ€èƒ½å†·å´æŒ‡ç¤ºå™¨ - è°ƒæ•´åˆ°å³ä¸‹è§’ */
        .skill-cooldown-indicator {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 75;
        }

        .skill-icon {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 206, 209, 0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .skill-icon.on-cooldown::after {
            content: attr(data-cooldown);
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #FF6347;
            border-radius: 8px;
        }

        /* æ•™å­¦é˜¶æ®µæ ‡é¢˜ */
        .stage-title {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #00CED1;
            text-shadow: 0 0 30px rgba(0, 206, 209, 0.8);
            opacity: 0;
            animation: stageIntro 3s ease-out;
            pointer-events: none;
            z-index: 150;
        }

        @keyframes stageIntro {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -70%) scale(0.8); }
        }
    </style>
</head>
<body>
    <!-- æ¸¸æˆç”»å¸ƒ -->
    <div id="gameCanvas">
        <!-- ç½‘æ ¼æ•ˆæœ -->
        <div class="grid-overlay"></div>
        
        <!-- åœ°é¢çº¿ -->
        <div class="ground-line"></div>

        <!-- å‡¯ç‘Ÿç³NPC -->
        <div class="katherine">
            <svg width="80" height="120" viewBox="0 0 80 120">
                <!-- èº«ä½“ -->
                <rect x="20" y="50" width="40" height="50" fill="#4B0082" stroke="#9B59B6" stroke-width="2"/>
                <!-- å¤´éƒ¨ -->
                <circle cx="40" cy="30" r="18" fill="#FDBCB4" stroke="#9B59B6" stroke-width="1"/>
                <!-- ARçœ¼é•œ -->
                <rect x="25" y="27" width="30" height="10" fill="rgba(0, 206, 209, 0.7)" stroke="#00CED1" stroke-width="1"/>
                <!-- å†’é™©è€…åä¼šæ ‡å¿— -->
                <circle cx="40" cy="75" r="10" fill="none" stroke="#FFD700" stroke-width="2"/>
                <path d="M40,65 L46,75 L40,85 L34,75 Z" fill="#FFD700"/>
            </svg>
        </div>

        <!-- æ´¾è’™åŠ©æ‰‹ -->
        <div class="paimon">
            <svg width="60" height="60" viewBox="0 0 60 60">
                <!-- æ´¾è’™èº«ä½“ -->
                <ellipse cx="30" cy="35" rx="15" ry="18" fill="#FFF5EE" stroke="#FFB6C1" stroke-width="2"/>
                <!-- æ´¾è’™å¤´éƒ¨ -->
                <circle cx="30" cy="20" r="12" fill="#FFF5EE" stroke="#FFB6C1" stroke-width="2"/>
                <!-- æ˜Ÿæ˜Ÿå¤´é¥° -->
                <path d="M30,6 L32,10 L36,10 L33,13 L34,17 L30,15 L26,17 L27,13 L24,10 L28,10 Z" 
                      fill="#FFD700" stroke="#FFA500" stroke-width="1"/>
                <!-- çœ¼ç› -->
                <circle cx="27" cy="20" r="1.5" fill="#000"/>
                <circle cx="33" cy="20" r="1.5" fill="#000"/>
                <!-- å˜´å·´ -->
                <path d="M27,23 Q30,25 33,23" stroke="#FFB6C1" stroke-width="1.5" fill="none"/>
                <!-- å°ç¿…è†€ -->
                <ellipse cx="15" cy="35" rx="6" ry="12" fill="#FFF" stroke="#FFB6C1" stroke-width="1" transform="rotate(-20 15 35)"/>
                <ellipse cx="45" cy="35" rx="6" ry="12" fill="#FFF" stroke="#FFB6C1" stroke-width="1" transform="rotate(20 45 35)"/>
            </svg>
        </div>

        <!-- æ´¾è’™å¯¹è¯æ¡† -->
        <div class="paimon-dialog" id="paimonDialog">
            <span id="paimonText">æ¬¢è¿æ¥åˆ°å†’é™©è€…åä¼šçš„è™šæ‹Ÿè®­ç»ƒå®¤ï¼</span>
        </div>

        <!-- ä»»åŠ¡ç›®æ ‡ -->
        <div class="mission-objective" id="missionObjective">
            ä»»åŠ¡ï¼šå­¦ä¹ åŸºç¡€ç§»åŠ¨
        </div>

        <!-- è¿›åº¦æ¡ -->
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- æ•™å­¦æç¤º -->
        <div class="tutorial-hint" id="tutorialHint">
            æŒ‰ <span class="key-hint">A</span> å’Œ <span class="key-hint">D</span> é”®å·¦å³ç§»åŠ¨
        </div>

        <!-- ç©å®¶æœºç”² -->
        <div class="player-mecha" id="playerMecha">
            <svg width="100" height="120" viewBox="0 0 100 120">
                <!-- ä½¿ç”¨ç®€åŒ–çš„èƒ¡æ¡ƒæœºç”²è®¾è®¡ -->
                <g transform="translate(50, 60)">
                    <!-- ä¸»èº¯å¹² -->
                    <path d="M 0,-40 L 15,-37 L 20,-20 L 22,8 L 18,25 L 10,38 L 0,42 
                             L -10,38 L -18,25 L -22,8 L -20,-20 L -15,-37 Z" 
                          fill="url(#mechaGradient)" stroke="#8B0000" stroke-width="2"/>
                    
                    <!-- å¤´éƒ¨ -->
                    <ellipse cx="0" cy="-30" rx="12" ry="10" fill="#2C1810" stroke="#8B0000" stroke-width="1.5"/>
                    
                    <!-- è§‚æµ‹çª— -->
                    <rect x="-8" y="-32" width="16" height="5" fill="#FF1493" opacity="0.9">
                        <animate attributeName="opacity" values="0.5;1;0.5" dur="2s" repeatCount="indefinite"/>
                    </rect>
                    
                    <!-- æ ¸å¿ƒ -->
                    <circle cx="0" cy="0" r="8" fill="none" stroke="#FF69B4" stroke-width="2.5" opacity="0.9">
                        <animate attributeName="r" values="7;10;7" dur="1.5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="0" cy="0" r="4" fill="#FF1493" opacity="0.7">
                        <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" repeatCount="indefinite"/>
                    </circle>
                    
                    <!-- å·¦è‡‚ -->
                    <rect x="-32" y="-12" width="10" height="30" fill="#1C0F08" stroke="#8B0000" stroke-width="1"/>
                    <!-- å³è‡‚ -->
                    <rect x="22" y="-12" width="10" height="30" fill="#1C0F08" stroke="#8B0000" stroke-width="1"/>
                    
                    <!-- å·¦è…¿ -->
                    <rect x="-12" y="25" width="10" height="25" fill="#1C0F08" stroke="#8B0000" stroke-width="1"/>
                    <!-- å³è…¿ -->
                    <rect x="2" y="25" width="10" height="25" fill="#1C0F08" stroke="#8B0000" stroke-width="1"/>
                </g>
                
                <!-- æœºç”²æ¸å˜å®šä¹‰ -->
                <defs>
                    <linearGradient id="mechaGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#2C1810"/>
                        <stop offset="50%" stop-color="#1C0F08"/>
                        <stop offset="100%" stop-color="#0F0704"/>
                    </linearGradient>
                </defs>
            </svg>
        </div>

        <!-- æŠ€èƒ½å†·å´æŒ‡ç¤ºå™¨ -->
        <div class="skill-cooldown-indicator">
            <div class="skill-icon" id="skillE">
                <span style="color: #9B59B6; font-size: 20px;">E</span>
            </div>
            <div class="skill-icon" id="skillQ">
                <span style="color: #FFD700; font-size: 20px;">Q</span>
            </div>
        </div>
    </div>

    <!-- ç§»åŠ¨ç«¯æ§åˆ¶ -->
    <div class="mobile-controls" id="mobileControls">
        <button class="control-btn" onclick="moveLeft()">â†</button>
        <button class="control-btn" onclick="jump()">â†‘</button>
        <button class="control-btn" onclick="moveRight()">â†’</button>
        <button class="control-btn" onclick="shoot()">å°„</button>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            currentStage: 0,
            playerX: 50, // ç™¾åˆ†æ¯”ä½ç½®
            playerY: 80,
            isMoving: false,
            canShoot: true,
            score: 0,
            tutorialProgress: 0,
            tutorialStages: [
                { name: "ç§»åŠ¨æ•™å­¦", objective: "å­¦ä¹ åŸºç¡€ç§»åŠ¨", hint: "æŒ‰ A/D é”®å·¦å³ç§»åŠ¨" },
                { name: "è·³è·ƒæ•™å­¦", objective: "å­¦ä¹ è·³è·ƒ", hint: "æŒ‰ ç©ºæ ¼é”® è·³è·ƒ" },
                { name: "å°„å‡»æ•™å­¦", objective: "å‡»ä¸­è®­ç»ƒå‡äºº", hint: "æŒ‰ é¼ æ ‡å·¦é”® å°„å‡»" },
                { name: "å…ƒç´ æˆ˜æŠ€", objective: "ä½¿ç”¨å…ƒç´ æˆ˜æŠ€", hint: "æŒ‰ E é”®é‡Šæ”¾ç«å…ƒç´ æˆ˜æŠ€" },
                { name: "å…ƒç´ çˆ†å‘", objective: "ä½¿ç”¨å…ƒç´ çˆ†å‘", hint: "æŒ‰ Q é”®é‡Šæ”¾å¤§æ‹›" },
                { name: "å…ƒç´ ååº”", objective: "è§¦å‘è’¸å‘ååº”", hint: "å…ˆæ–½åŠ æ°´å…ƒç´ ï¼Œå†ä½¿ç”¨ç«å…ƒç´ " },
                { name: "å®æˆ˜æµ‹è¯•", objective: "å‡»è´¥æ‰€æœ‰è®­ç»ƒå‡äºº", hint: "ç»¼åˆè¿ç”¨æ‰€å­¦æŠ€èƒ½" }
            ],
            enemies: [],
            bullets: [],
            effects: []
        };

        // æ´¾è’™è¯­éŸ³åº“
        const paimonLines = {
            welcome: [
                "æ¬¢è¿æ¥åˆ°è™šæ‹Ÿè®­ç»ƒå®¤ï¼æˆ‘æ˜¯æ´¾è’™ï¼Œä½ çš„åº”æ€¥...å•Šä¸ï¼Œæ˜¯ä½ çš„è®­ç»ƒåŠ©æ‰‹ï¼",
                "å“‡ï¼æ–°çš„é©¾é©¶å‘˜ï¼è®©æ´¾è’™æ¥æ•™ä½ æ€ä¹ˆæ“ä½œæœºç”²å§ï¼",
                "å‡†å¤‡å¥½äº†å—ï¼Ÿè®­ç»ƒé©¬ä¸Šå¼€å§‹å’¯ï¼"
            ],
            movement: [
                "è¯•è¯•ç”¨Aå’ŒDé”®å·¦å³ç§»åŠ¨å§ï¼",
                "å¾ˆå¥½ï¼ä½ å­¦å¾—çœŸå¿«ï¼",
                "ç§»åŠ¨æ˜¯æˆ˜æ–—çš„åŸºç¡€å“¦ï½"
            ],
            jump: [
                "æŒ‰ç©ºæ ¼é”®å¯ä»¥è·³è·ƒï¼",
                "è·³èµ·æ¥ï¼å¯ä»¥èº²é¿åœ°é¢æ”»å‡»å“¦ï¼",
                "å“‡ï¼è·³å¾—çœŸé«˜ï¼"
            ],
            shoot: [
                "å·¦é”®å°„å‡»ï¼ç„å‡†é‚£äº›è®­ç»ƒå‡äººï¼",
                "å‘½ä¸­äº†ï¼ä½ æ˜¯å¤©ç”Ÿçš„å°„æ‰‹ï¼",
                "è¿ç»­å°„å‡»å¯ä»¥é€ æˆæ›´å¤šä¼¤å®³ï¼"
            ],
            skill: [
                "Eé”®é‡Šæ”¾å…ƒç´ æˆ˜æŠ€ï¼",
                "ç«å…ƒç´ çš„åŠ›é‡ï¼Œç‡ƒçƒ§å§ï¼",
                "å…ƒç´ æˆ˜æŠ€æœ‰å†·å´æ—¶é—´ï¼Œè¦åˆç†ä½¿ç”¨å“¦ï¼"
            ],
            ultimate: [
                "èƒ½é‡æ»¡äº†ï¼æŒ‰Qé”®é‡Šæ”¾å¤§æ‹›ï¼",
                "è¿™å°±æ˜¯å…ƒç´ çˆ†å‘çš„å¨åŠ›ï¼",
                "å¤ªå‰å®³äº†ï¼ç®€ç›´å°±åƒçœŸæ­£çš„è‹±é›„ï¼"
            ],
            reaction: [
                "å…ƒç´ ååº”ï¼è¿™æ‰æ˜¯æˆ˜æ–—çš„ç²¾é«“ï¼",
                "è’¸å‘ååº”èƒ½é€ æˆ2å€ä¼¤å®³ï¼",
                "ä¸åŒçš„å…ƒç´ ç»„åˆæœ‰ä¸åŒçš„æ•ˆæœå“¦ï¼"
            ],
            encourage: [
                "åŠ æ²¹ï¼ä½ å¯ä»¥çš„ï¼",
                "åˆ«æ”¾å¼ƒï¼å†è¯•ä¸€æ¬¡ï¼",
                "ç›¸ä¿¡è‡ªå·±ï¼ä½ å·²ç»å¾ˆæ£’äº†ï¼"
            ],
            complete: [
                "æ­å–œå®Œæˆè®­ç»ƒï¼",
                "ä½ å·²ç»æ˜¯åˆæ ¼çš„æœºç”²é©¾é©¶å‘˜äº†ï¼",
                "å¤ªæ£’äº†ï¼å‡¯ç‘Ÿç³ä¸€å®šä¼šå¾ˆé«˜å…´çš„ï¼"
            ]
        };

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            showPaimonDialog(paimonLines.welcome[0]);
            startTutorialStage(0);
            setupEventListeners();
            gameLoop();
        }

        // æ˜¾ç¤ºæ´¾è’™å¯¹è¯
        function showPaimonDialog(text) {
            const dialog = document.getElementById('paimonDialog');
            const textElement = document.getElementById('paimonText');
            textElement.textContent = text;
            dialog.classList.add('active');
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                dialog.classList.remove('active');
            }, 3000);
        }

        // å¼€å§‹æ•™å­¦é˜¶æ®µ
        function startTutorialStage(stage) {
            if (stage >= gameState.tutorialStages.length) {
                completeTutorial();
                return;
            }

            gameState.currentStage = stage;
            const stageData = gameState.tutorialStages[stage];
            
            // æ›´æ–°UI
            document.getElementById('missionObjective').textContent = `ä»»åŠ¡ï¼š${stageData.objective}`;
            document.getElementById('tutorialHint').innerHTML = stageData.hint.replace(/(\S+é”®)/g, '<span class="key-hint">$1</span>');
            
            // æ˜¾ç¤ºé˜¶æ®µæ ‡é¢˜
            showStageTitle(stageData.name);
            
            // æ ¹æ®ä¸åŒé˜¶æ®µåˆå§‹åŒ–
            switch(stage) {
                case 0: // ç§»åŠ¨æ•™å­¦
                    showPaimonDialog(paimonLines.movement[0]);
                    break;
                case 1: // è·³è·ƒæ•™å­¦
                    showPaimonDialog(paimonLines.jump[0]);
                    break;
                case 2: // å°„å‡»æ•™å­¦
                    showPaimonDialog(paimonLines.shoot[0]);
                    spawnTrainingDummy(70, 80);
                    break;
                case 3: // å…ƒç´ æˆ˜æŠ€
                    showPaimonDialog(paimonLines.skill[0]);
                    spawnTrainingDummy(30, 80);
                    break;
                case 4: // å…ƒç´ çˆ†å‘
                    showPaimonDialog(paimonLines.ultimate[0]);
                    spawnMultipleDummies();
                    break;
                case 5: // å…ƒç´ ååº”
                    showPaimonDialog(paimonLines.reaction[0]);
                    createElementZone();
                    break;
                case 6: // å®æˆ˜æµ‹è¯•
                    showPaimonDialog("ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿›è¡Œæœ€ç»ˆæµ‹è¯•ï¼");
                    spawnFinalChallenge();
                    break;
            }
            
            // é‡ç½®è¿›åº¦
            gameState.tutorialProgress = 0;
            updateProgress(0);
        }

        // æ˜¾ç¤ºé˜¶æ®µæ ‡é¢˜
        function showStageTitle(title) {
            const titleElement = document.createElement('div');
            titleElement.className = 'stage-title';
            titleElement.textContent = title;
            document.getElementById('gameCanvas').appendChild(titleElement);
            
            setTimeout(() => {
                titleElement.remove();
            }, 3000);
        }

        // ç”Ÿæˆè®­ç»ƒå‡äºº
        function spawnTrainingDummy(x, y) {
            const dummy = document.createElement('div');
            dummy.className = 'training-dummy';
            dummy.style.left = x + '%';
            dummy.style.bottom = '100px';
            dummy.innerHTML = `
                <svg width="60" height="80" viewBox="0 0 60 80">
                    <rect x="10" y="20" width="40" height="50" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <circle cx="30" cy="15" r="10" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <rect x="25" y="35" width="10" height="10" fill="#FFD700"/>
                    <text x="30" y="75" text-anchor="middle" fill="#FFF" font-size="12">HP: 100</text>
                </svg>
            `;
            dummy.dataset.hp = 100;
            document.getElementById('gameCanvas').appendChild(dummy);
            gameState.enemies.push(dummy);
        }

        // ç”Ÿæˆå¤šä¸ªå‡äºº
        function spawnMultipleDummies() {
            [20, 40, 60, 80].forEach(x => {
                spawnTrainingDummy(x, 80);
            });
        }

        // åˆ›å»ºå…ƒç´ ååº”åŒºåŸŸ
        function createElementZone() {
            const zone = document.createElement('div');
            zone.className = 'element-tutorial-zone';
            zone.style.left = '40%';
            zone.style.bottom = '150px';
            zone.innerHTML = 'æ°´å…ƒç´ åŒºåŸŸ';
            zone.dataset.element = 'hydro';
            document.getElementById('gameCanvas').appendChild(zone);
            
            spawnTrainingDummy(50, 80);
        }

        // æœ€ç»ˆæŒ‘æˆ˜
        function spawnFinalChallenge() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const x = 20 + Math.random() * 60;
                    spawnTrainingDummy(x, 80);
                }, i * 500);
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // é¼ æ ‡æ§åˆ¶
            document.addEventListener('click', handleClick);
            
            // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
            if ('ontouchstart' in window) {
                document.getElementById('mobileControls').style.display = 'flex';
            }
        }

        // é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
        function handleKeyDown(e) {
            const player = document.getElementById('playerMecha');
            
            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    movePlayer(-2);
                    checkMovementProgress();
                    break;
                case 'd':
                case 'arrowright':
                    movePlayer(2);
                    checkMovementProgress();
                    break;
                case ' ':
                    e.preventDefault();
                    playerJump();
                    break;
                case 'e':
                    useSkill();
                    break;
                case 'q':
                    useUltimate();
                    break;
            }
        }

        // é”®ç›˜æ¾å¼€äº‹ä»¶
        function handleKeyUp(e) {
            gameState.isMoving = false;
        }

        // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
        function handleClick(e) {
            if (gameState.currentStage >= 2) { // å°„å‡»æ•™å­¦å¼€å§‹åæ‰èƒ½å°„å‡»
                playerShoot(e.clientX, e.clientY);
            }
        }

        // ç§»åŠ¨ç©å®¶
        function movePlayer(direction) {
            gameState.playerX = Math.max(5, Math.min(95, gameState.playerX + direction));
            const player = document.getElementById('playerMecha');
            player.style.left = gameState.playerX + '%';
            gameState.isMoving = true;
        }

        // ç©å®¶è·³è·ƒ
        function playerJump() {
            const player = document.getElementById('playerMecha');
            if (player.classList.contains('jumping')) return;
            
            player.classList.add('jumping');
            player.style.transition = 'bottom 0.3s ease-out';
            player.style.bottom = '200px';
            
            setTimeout(() => {
                player.style.transition = 'bottom 0.3s ease-in';
                player.style.bottom = '100px';
                setTimeout(() => {
                    player.classList.remove('jumping');
                    player.style.transition = 'left 0.1s ease';
                }, 300);
            }, 300);
            
            // è·³è·ƒæ•™å­¦è¿›åº¦
            if (gameState.currentStage === 1) {
                updateProgress(gameState.tutorialProgress + 25);
                showPaimonDialog(paimonLines.jump[2]);
            }
        }

        // ç©å®¶å°„å‡»
        function playerShoot(targetX, targetY) {
            if (!gameState.canShoot) return;
            
            const bullet = document.createElement('div');
            bullet.className = 'bullet';
            bullet.style.left = gameState.playerX + '%';
            bullet.style.bottom = '150px';
            document.getElementById('gameCanvas').appendChild(bullet);
            
            // è®¡ç®—å°„å‡»æ–¹å‘
            const rect = document.getElementById('gameCanvas').getBoundingClientRect();
            const startX = (gameState.playerX / 100) * rect.width;
            const startY = rect.height - 150;
            const angle = Math.atan2(targetY - startY, targetX - startX);
            
            // å­å¼¹ç§»åŠ¨
            let bulletX = gameState.playerX;
            let bulletY = 150;
            const speed = 5;
            
            const bulletInterval = setInterval(() => {
                bulletX += Math.cos(angle) * speed;
                bulletY -= Math.sin(angle) * speed;
                
                bullet.style.left = bulletX + '%';
                bullet.style.bottom = bulletY + 'px';
                
                // æ£€æµ‹ç¢°æ’
                checkBulletCollision(bullet, bulletX, bulletY);
                
                // ç§»é™¤è¶…å‡ºå±å¹•çš„å­å¼¹
                if (bulletX < 0 || bulletX > 100 || bulletY < 0 || bulletY > window.innerHeight) {
                    bullet.remove();
                    clearInterval(bulletInterval);
                }
            }, 16);
            
            // å°„å‡»å†·å´
            gameState.canShoot = false;
            setTimeout(() => {
                gameState.canShoot = true;
            }, 200);
        }

        // æ£€æµ‹å­å¼¹ç¢°æ’
        function checkBulletCollision(bullet, x, y) {
            gameState.enemies.forEach(enemy => {
                const enemyRect = enemy.getBoundingClientRect();
                const bulletRect = bullet.getBoundingClientRect();
                
                if (bulletRect.left < enemyRect.right &&
                    bulletRect.right > enemyRect.left &&
                    bulletRect.top < enemyRect.bottom &&
                    bulletRect.bottom > enemyRect.top) {
                    
                    // å‡»ä¸­æ•Œäºº
                    bullet.remove();
                    damageEnemy(enemy, 20);
                    showDamageNumber(enemy, 20, 'normal');
                    
                    // å°„å‡»æ•™å­¦è¿›åº¦
                    if (gameState.currentStage === 2) {
                        updateProgress(gameState.tutorialProgress + 20);
                        if (gameState.tutorialProgress >= 100) {
                            showPaimonDialog(paimonLines.shoot[1]);
                        }
                    }
                }
            });
        }

        // ä½¿ç”¨æŠ€èƒ½
        function useSkill() {
            const skillIcon = document.getElementById('skillE');
            if (skillIcon.classList.contains('on-cooldown')) return;
            
            // åˆ›å»ºç«å…ƒç´ æ•ˆæœ
            createElementEffect(gameState.playerX, 150, 'fire');
            
            // èŒƒå›´ä¼¤å®³
            gameState.enemies.forEach(enemy => {
                const enemyX = parseFloat(enemy.style.left);
                if (Math.abs(enemyX - gameState.playerX) < 20) {
                    damageEnemy(enemy, 50);
                    showDamageNumber(enemy, 50, 'elemental');
                }
            });
            
            // æŠ€èƒ½å†·å´
            skillIcon.classList.add('on-cooldown');
            skillIcon.dataset.cooldown = '6';
            let cooldown = 6;
            
            const cooldownInterval = setInterval(() => {
                cooldown--;
                skillIcon.dataset.cooldown = cooldown;
                if (cooldown <= 0) {
                    skillIcon.classList.remove('on-cooldown');
                    clearInterval(cooldownInterval);
                }
            }, 1000);
            
            // å…ƒç´ æˆ˜æŠ€æ•™å­¦è¿›åº¦
            if (gameState.currentStage === 3) {
                updateProgress(100);
                showPaimonDialog(paimonLines.skill[1]);
            }
        }

        // ä½¿ç”¨å¤§æ‹›
        function useUltimate() {
            const skillIcon = document.getElementById('skillQ');
            if (skillIcon.classList.contains('on-cooldown')) return;
            
            // å…¨å±ç«ç„°æ•ˆæœ
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const x = 20 + i * 15;
                    createElementEffect(x, 200, 'fire');
                    
                    // ä¼¤å®³æ‰€æœ‰æ•Œäºº
                    gameState.enemies.forEach(enemy => {
                        damageEnemy(enemy, 100);
                        showDamageNumber(enemy, 100, 'critical');
                    });
                }, i * 100);
            }
            
            // å¤§æ‹›å†·å´
            skillIcon.classList.add('on-cooldown');
            skillIcon.dataset.cooldown = '20';
            let cooldown = 20;
            
            const cooldownInterval = setInterval(() => {
                cooldown--;
                skillIcon.dataset.cooldown = cooldown;
                if (cooldown <= 0) {
                    skillIcon.classList.remove('on-cooldown');
                    clearInterval(cooldownInterval);
                }
            }, 1000);
            
            // å…ƒç´ çˆ†å‘æ•™å­¦è¿›åº¦
            if (gameState.currentStage === 4) {
                updateProgress(100);
                showPaimonDialog(paimonLines.ultimate[1]);
            }
        }

        // åˆ›å»ºå…ƒç´ æ•ˆæœ
        function createElementEffect(x, y, element) {
            const effect = document.createElement('div');
            effect.className = 'element-effect';
            effect.style.left = x + '%';
            effect.style.bottom = y + 'px';
            
            const colors = {
                fire: 'radial-gradient(circle, #FF6347, #FF4500, transparent)',
                water: 'radial-gradient(circle, #00CED1, #4682B4, transparent)',
                electro: 'radial-gradient(circle, #9B59B6, #8A2BE2, transparent)'
            };
            
            effect.style.background = colors[element] || colors.fire;
            document.getElementById('gameCanvas').appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 500);
        }

        // ä¼¤å®³æ•Œäºº
        function damageEnemy(enemy, damage) {
            let hp = parseInt(enemy.dataset.hp) || 100;
            hp = Math.max(0, hp - damage);
            enemy.dataset.hp = hp;
            
            // æ›´æ–°è¡€æ¡æ˜¾ç¤º
            const hpText = enemy.querySelector('text');
            if (hpText) {
                hpText.textContent = `HP: ${hp}`;
            }
            
            // æ•Œäººæ­»äº¡
            if (hp <= 0) {
                enemy.style.transition = 'opacity 0.5s';
                enemy.style.opacity = '0';
                setTimeout(() => {
                    enemy.remove();
                    const index = gameState.enemies.indexOf(enemy);
                    if (index > -1) {
                        gameState.enemies.splice(index, 1);
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦å®Œæˆå½“å‰é˜¶æ®µ
                    checkStageCompletion();
                }, 500);
            }
        }

        // æ˜¾ç¤ºä¼¤å®³æ•°å­—
        function showDamageNumber(target, damage, type) {
            const number = document.createElement('div');
            number.className = `damage-number damage-${type}`;
            number.textContent = damage;
            
            const rect = target.getBoundingClientRect();
            const canvasRect = document.getElementById('gameCanvas').getBoundingClientRect();
            
            number.style.left = (rect.left - canvasRect.left + rect.width / 2) + 'px';
            number.style.top = (rect.top - canvasRect.top) + 'px';
            
            document.getElementById('gameCanvas').appendChild(number);
            
            setTimeout(() => {
                number.remove();
            }, 1000);
        }

        // æ£€æŸ¥ç§»åŠ¨è¿›åº¦
        function checkMovementProgress() {
            if (gameState.currentStage === 0) {
                updateProgress(Math.min(100, gameState.tutorialProgress + 5));
                if (gameState.tutorialProgress >= 50 && gameState.tutorialProgress < 55) {
                    showPaimonDialog(paimonLines.movement[1]);
                }
            }
        }

        // æ£€æŸ¥é˜¶æ®µå®Œæˆ
        function checkStageCompletion() {
            if (gameState.currentStage === 6 && gameState.enemies.length === 0) {
                // æœ€ç»ˆæµ‹è¯•å®Œæˆ
                updateProgress(100);
                showPaimonDialog(paimonLines.complete[0]);
                setTimeout(() => {
                    showAchievement("è®­ç»ƒå®Œæˆï¼", "ä½ å·²ç»æŒæ¡äº†æ‰€æœ‰åŸºç¡€æŠ€èƒ½ï¼");
                }, 1000);
            } else if (gameState.enemies.length === 0 && gameState.currentStage >= 2) {
                // å…¶ä»–æˆ˜æ–—é˜¶æ®µå®Œæˆ
                updateProgress(100);
            }
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(progress) {
            gameState.tutorialProgress = Math.min(100, progress);
            document.getElementById('progressFill').style.width = gameState.tutorialProgress + '%';
            
            // è¿›åº¦æ»¡æ—¶è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
            if (gameState.tutorialProgress >= 100) {
                setTimeout(() => {
                    startTutorialStage(gameState.currentStage + 1);
                }, 1500);
            }
        }

        // æ˜¾ç¤ºæˆå°±
        function showAchievement(title, description) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.innerHTML = `
                <h2>ğŸ† ${title}</h2>
                <p>${description}</p>
            `;
            document.body.appendChild(achievement);
            
            setTimeout(() => {
                achievement.style.animation = 'achievementPop 0.5s ease-out reverse';
                setTimeout(() => {
                    achievement.remove();
                }, 500);
            }, 3000);
        }

        // å®Œæˆæ•™ç¨‹
        function completeTutorial() {
            showPaimonDialog("æ­å–œä½ å®Œæˆäº†æ‰€æœ‰è®­ç»ƒï¼å‡¯ç‘Ÿç³ä¼šä¸ºä½ æ„Ÿåˆ°éª„å‚²çš„ï¼");
            setTimeout(() => {
                showAchievement("æ–°æ‰‹æ¯•ä¸š", "è·å¾—ç§°å·ï¼šè§ä¹ æœºç”²é©¾é©¶å‘˜");
                
                // æ˜¾ç¤ºè¿”å›ä¸»èœå•æŒ‰é’®
                const returnBtn = document.createElement('button');
                returnBtn.textContent = 'è¿”å›ä¸»èœå•';
                returnBtn.style.cssText = `
                    position: absolute;
                    bottom: 50px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 15px 30px;
                    font-size: 18px;
                    background: linear-gradient(135deg, #9B59B6, #00CED1);
                    border: none;
                    border-radius: 10px;
                    color: white;
                    cursor: pointer;
                    z-index: 200;
                `;
                returnBtn.onclick = () => {
                    window.location.href = 'index.html';
                };
                document.body.appendChild(returnBtn);
            }, 4000);
        }

        // ç§»åŠ¨ç«¯æ§åˆ¶å‡½æ•°
        function moveLeft() {
            movePlayer(-2);
            checkMovementProgress();
        }

        function moveRight() {
            movePlayer(2);
            checkMovementProgress();
        }

        function jump() {
            playerJump();
        }

        function shoot() {
            const rect = document.getElementById('gameCanvas').getBoundingClientRect();
            playerShoot(rect.width / 2, rect.height / 2);
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            
            requestAnimationFrame(gameLoop);
        }

        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('load', () => {
            initGame();
        });
    </script>
</body>
</html>